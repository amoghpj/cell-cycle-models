#+PROPERTY: header-args:python :session bifur :tangle app.py :comment link 
#+LATEX_HEADER: \usemintedstyle{tango}%colorful
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \definecolor{bg}{rgb}{0.9,0.9,0.9}
#+LATEX_HEADER: \setminted{linenos=True,bgcolor=bg}
#+LATEX_HEADER: \usepackage[bottom=0.5in,margin=1in]{geometry}
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.integrate import odeint
from io import BytesIO
import streamlit as st
#+END_SRC 

#+RESULTS:
Setup: https://towardsdatascience.com/quickly-build-and-deploy-an-application-with-streamlit-988ca08c7e83
Following cite:2001_JTB_Tyson_Antagonism_Hysteresis_Irreversible
* App
** Test
#+begin_src python
  def lotkavolterra(X, t, args):
      rabbit, fox = X
      alpha= 1.1
      beta = 0.4
      delta = 0.1
      gamma = 0.4
      drabbit = alpha*rabbit - beta*rabbit*fox
      dfox = delta*fox*rabbit  - gamma*fox
      return([drabbit, dfox])

  def testLV():
      """Lotka-Volterra test"""
      f, ax = plt.subplots(1,1)
      x0 = [10, 5]
      rabbiti = st.slider('rabbit', min_value=0, max_value=20, step=1)
      foxi = st.slider('fox', min_value=0, max_value=20, step=1)
      X = odeint(lotkavolterra, [rabbiti, foxi], np.linspace(0,10,500), args = ({},))
      gridsize =20
      maxrabbit = 20
      maxfox = 10
      xlim = np.linspace(-1,maxrabbit,gridsize)
      ylim = np.linspace(-1,maxfox,gridsize)
      makePP(lotkavolterra, xlim, ylim,ax, gridsize, {})
      ax.plot(X[:,0],X[:,1])
      ax.plot(rabbiti, foxi, 'ko')
      ax.axhline(1.1/0.4)
      ax.axvline(0.1/0.4)
      ax.set_xlim(-1,maxrabbit)
      ax.set_ylim(-1,maxfox)
      ax.set_xlabel('rabbit')
      ax.set_ylabel('fox')
      st.pyplot()
#+end_src
** Helpers
*** phaseplane
#+begin_src python
  def makePP(model, xlim, ylim, ax, gridsize,args):
      xstep = 0.5*max(xlim)/gridsize# length of vectors
      ystep = 0.5*max(ylim)/gridsize
      for x in xlim:
          for y in ylim:
              der = model([x,y],0.1, args)
              theta = np.arctan(abs(der[1]/der[0]))
              xsign = 1.
              ysign = 1.
              if der[0] < 0:
                  xsign = -1
              if der[1] < 0:
                  ysign = -1
              deltax = xstep*np.cos(theta)*xsign
              deltay = ystep*np.sin(theta)*ysign

              ax.arrow(x,np.log10(y),
                       deltax,
                       deltay,
                       head_width=0.5*min(xstep, ystep),
                       color='k',
                       alpha=0.3,
                       length_includes_head=False)
#+end_src
*** root finding
#+begin_src python
  def getRoots(y1, y2):
      err = [abs(y1[i] - y2[i]) for i in range(len(y1))]
      winsize = 2
      differr = [(err[i+winsize] - err[i])/winsize for i in range(len(err)-winsize)]
      solutions = []

      for i in range(len(differr)-winsize):
          if err[i+winsize] < 0.05 and err[i] < 0.05:
              if differr[i + winsize] >0 and differr[i] < 0 :
                  solutions.append(i+1)

      f, ax = plt.subplots(2,1)
      ax[0].plot(np.log10(err))
      signde = []
      for d in differr:
          if d > 0 :
              signde.append(1)
          elif d<0:
              signde.append(-1)
          else:
              signde.append(0)
      ax[1].plot(signde)
      extreme = [err[s] for s in solutions]
      #ax[0].axhline(np.log10(min(extreme)), color='b')
      for s in solutions:
          ax[1].plot(s,0,'r.')
          ax[0].axvline(s,color='r',alpha=0.1)
      ax[1].set_title('err')
      #st.pyplot()
      plt.close()
      return solutions

#+end_src
** Solver
#+begin_src python
  def integrate(func, x0, tspan, parameters, stepsize=0.01, method='rk45'):
      methoddict = {'rk45':rk45,
                    'euler':euler}
      xprev = x0
      t0 = min(tspan)
      tmax = max(tspan)
      size = int(tmax/stepsize)
      timecourse = np.zeros(shape=(size, len(x0)))
      t = t0
      counter = 0
      divide = False
      while counter < size:
          dX = func(xprev, t, parameters)
          x = []
          x = xprev + stepsize*(methoddict[method](func, xprev, t, stepsize, parameters))
          # cycb
          if x[1] < 0.1 and timecourse[counter-1,1] >0:# and division = False:
              divide = True
              #x = [v/2. for v in x]
          if divide is True:
              x[5] = 0.6 # mass
              divide = False
          xprev = x
          t += stepsize
          timecourse[counter,: ] = x
          counter += 1
      return(timecourse)

  def euler(function, x, t, args):
      dx = function(x, t, args)
      return dx

  def rk45(function, x, t, stepsize, args):
      k1 = function(x, t, args)
      k2 = function(x + k1*stepsize/2., t + stepsize/2, args)
      k3 = function(x + k2*stepsize/2., t + stepsize/2., args)
      k4 = function(x + k3*stepsize/2., t + stepsize, args)
      return(k1 + 2.*k2 + 2.*k3 + k4)/6.
#+end_src
** Model definitions
 #+begin_src python
   def fig1model(X, t, args):
       m = args['m']
       k1 = args['k1']
       k2d = args['k2d']
       k2dd = args['k2dd']
       k2ddd = args['k2ddd']
       k3d = args['k3d']
       k3dd = args['k3dd']
       k4d = args['k4d']
       k4 = args['k4']
       A = args['A']
       J3 = args['J3']
       J4 = args['J4']
       cdh1, cycb = X
       dcycb = k1- (k2d + k2dd * cdh1)*cycb
       dcdh1 = ((k3d + k3dd*A)*(1 - cdh1))/(J3 + 1 - cdh1) - (k4*m*cycb*cdh1)/(J4 + cdh1)
       return([dcdh1, dcycb])

 #+end_src
** CyclinB/CDK-Cdh1/APC antagonism
 #+begin_src python
   def cycbnc_fig2(cdh1, parameters):
       beta = parameters['k1']/parameters['k2dd']
       J = parameters['k2d']/parameters['k2dd']
       cycb = [beta/(J + c) for c in cdh1]
       return cycb

   def cdh1nc_fig2(cdh1,parameters):
       p = (parameters['k3d'] + parameters['k3dd']*parameters['A'])/(parameters['k4']*parameters['m'])
       cycb = [p*((1-c)*(parameters['J4'] + c))/(c*(parameters['J3'] + 1 - c)) for c in cdh1]
       return cycb

   def makeFig2(parameters):
       with open('./markdown/two-variable-timecourse.md','r') as infile:
           sec1text = ''.join(infile.readlines())
       st.markdown(sec1text)
       ####################################
       ### Time courses
       Cdh1_i = st.slider(label='Cdh1',key='cdh1fig2tc', min_value=0.0, max_value=1.0, value=0.87,step=0.051)
       CycB_i = st.slider(label='log(CycB)',key='cdh1fig2tc', min_value=-2., max_value=1., value=-1.8,step=0.1)
       mval = st.slider(label='Mass', key='massfig2tc',min_value=0.3, max_value=0.7, value=0.3,step=0.01)    
       f, ax = plt.subplots(1,1)
       t = np.linspace(0,100,500)
       cdh1 = np.logspace(-6,0.1,8000)
       parameters['m'] =  mval
       y = odeint(fig1model, [Cdh1_i, 10**CycB_i],t,args=(parameters,))
       ax.plot(t, y[:,0],'k', label = 'Cdh1')
       ax.set_ylim(0,1.0)
       ax1 = ax.twinx()
       ax.set_ylabel('[Cdh1]')
       ax.set_xlabel('time (min)')
       ax1.set_ylabel('[CycB]')
       ax1.plot(t, y[:,1],'k--', label = 'CycB')
       ax1.set_ylim(1e-2,10.)
       ax1.set_yscale('log')
       ax.legend()
       ax1.legend()
       ax.set_title('mass = ' + str(round(mval, 2)))
       st.pyplot()
       plt.close()

       ###################################
       ### Nullclines
       with open('./markdown/two-variable-nullcline.md','r') as infile:
           sec1text = ''.join(infile.readlines())
       st.markdown(sec1text)
       Cdh1_i = st.slider(label='Cdh1',key='cdh1fig2nc', min_value=0.0, max_value=1.0, value=0.9,step=0.1)
       CycB_i = st.slider(label='log(CycB)', key='cycbfig2nc',min_value=-2., max_value=1., value=-1.9,step=0.1)
       mval = st.slider(label='Mass', key='massfig2nc',min_value=0.3, max_value=0.7, value=0.3,step=0.01)    
       parameters['m'] = mval

       cycb1 = cycbnc_fig2(cdh1, parameters)
       cycb2 = cdh1nc_fig2(cdh1, parameters)
       parameters['m'] =  mval
       solutions = getRoots(np.log10(cycb1), np.log10(cycb2))
       plt.close()

       y = odeint(fig1model, [Cdh1_i, 10**CycB_i],t,args=(parameters,))

       f, ax = plt.subplots(1,1)
       ax.plot(cdh1,np.log10(cycb1), 'b', label='CycB nullcline')
       ax.plot(cdh1,np.log10(cycb2), 'r', label='Cdh1 nullcline')
       ax.plot(Cdh1_i,CycB_i,'ko')
       ax.plot(y[:,0], np.log10(y[:,1]), 'k--',alpha=0.5, lw=2.0)
       ax.plot(y[-1,0], np.log10(y[-1,1]), 'ro', lw=2.0)

       for s in solutions:
           ax.plot(cdh1[s], np.log10(cycb1[s]), 'go')
       ax.annotate("G1",(0.9,-1))
       ax.annotate("S/G2/M",(0.01,0.1))
       ax.set_ylabel('log([CycB])')
       ax.set_xlabel('[Cdh1]')
       ax.set_xlim([-0.05,1.01]) 
       ax.set_ylim([-2,1]) 
       ax.legend()

       plt.tight_layout()
       st.pyplot()
       #####################################3
       ### Conclusions
       with open('./markdown/two-variable-conclusion.md','r') as infile:
           sec1text = ''.join(infile.readlines())
       st.markdown(sec1text)

 #+end_src

 #+RESULTS:

** Hystersis
#+begin_src python
  def makeFig3(parameters):       
      mvals = np.linspace(0.05,0.6,250)

      cdh1 = np.append(np.logspace(-9, -4, 4000), np.logspace(-4,0.1,1000))
      hyst = []
      pvals = []
      for m in mvals:
          p = (parameters['k3d'] + parameters['k3dd']*parameters['A'])/(parameters['k4']*m)
          parameters['m'] = m
          cycb1 = cycbnc_fig2(cdh1, parameters)
          cycb2 = cdh1nc_fig2(cdh1, parameters)
          solutions = getRoots(np.log10(cycb1), np.log10(cycb2))
          #pvals.append(p)
          for s in solutions:
              hyst.append(np.log10(cycb1[s]))
              pvals.append(p)
      # plt.plot(mvals,pvals)
      plt.plot(pvals, hyst,'k.')
      # plt.xlabel('m')
      # plt.ylabel('p')
      plt.xlabel('p')
      plt.ylabel('[CycB]')
      st.pyplot()

#+end_src
** Full model
*** definition
#+begin_src python
  def fullmodel(X, t, args):
      k1 = args['k1']
      k2d = args['k2d']
      k2dd = args['k2dd']
      k2ddd = args['k2ddd']
      k3d = args['k3d']
      k3dd = args['k3dd']
      k4d = args['k4d']
      k4 = args['k4']
      A = args['A']
      J3 = args['J3']
      J4 = args['J4']
      mu = args['mu']
      J5 = args['J5']
      Mad = args['Mad']
      k6 = args['k6']
      k7 = args['k7']
      k8 = args['k8']
      n = args['n']
      k5d = args['k5d']
      k5dd = args['k5dd']
      J7 = args['J7']
      J8 = args['J8']
      mstar = args['mstar']
      k9 = args['k9']
      k10 = args['k10']
      cdh1, cycb, cdc20t, cdc20a, iep, m = X
      # if cycb < 0.1:
      #     m = m/2.
      dcdh1 = ((k3d + k3dd*cdc20a)*(1 - cdh1))/(J3 + 1 - cdh1) - (k4*m*cycb*cdh1)/(J4 + cdh1)
      dcycb = k1- (k2d + k2dd * cdh1)*cycb    
      dcdc20t = k5d + k5dd*( (cycb*m/J5)**n /(1+ (cycb*(m/J5))**n )) - k6*cdc20t
      dcdc20a = (k7*iep*(cdc20t-cdc20a)/(J7 + cdc20t - cdc20a)) - (k8*Mad*cdc20a)/(J8+cdc20a) - k6*cdc20a
      diep = k9*m*cycb*(1-iep) - k10*iep
      dm = mu*m*(1-m/mstar)
      return np.array(([dcdh1, dcycb, dcdc20t, dcdc20a, diep, dm]))
#+end_src
*** call
#+begin_src python
  def plottimecourses(parameters):
      x0 = [1.0, 0.5,1.5, 1.4, 0.7, 0.6]
      stepsize = 0.01
      tmax = 160
      t= np.linspace(0, tmax, int(tmax/stepsize))
      #y = odeint(fullmodel,x0, t, args=(parameters,))
      y = integrate(fullmodel, x0, t, parameters, stepsize=stepsize)
      f , ax = plt.subplots(3,1)#, figsize=(1,3))
      ax[0].plot(t,y[:,5], label='m')
      ax[0].legend()
      ax[1].plot(t,y[:,0], label='Cdh1')
      ax[1].plot(t,y[:,1], label='CycB')
      ax[1].legend()
      ax[2].plot(t,y[:,2], label='Cdc20T')
      ax[2].plot(t,y[:,3], label='Cdc20A')
      ax[2].plot(t,y[:,4], label='IEP')        
      ax[2].set_ylim([0,1.8])
      ax[2].legend()
      plt.tight_layout()
      st.pyplot()
#+end_src
** Make introduction
#+begin_src python
  def makeIntroPage():
      with open('markdown/intro.md','r') as infile:
          introtext = ''.join(infile.readlines())
      st.markdown(introtext)
#+end_src
** Function calls
 #+begin_src python
   def main():
       # parameterdict
       parameters = {
           'k1':0.04,
           'k2d':0.04,
           'k2dd':1.,
           'k2ddd':1.,
           'k3d':1.,
           'k3dd':10.,
           'k4d':2.,
           'k4':35.,
           'A':0.00,
           'J3':0.04,
           'J4':0.04,
           'k5d':0.005,
           'k5dd':0.2,
           'k6':0.1,
           'Mad':1.0,
           'k7':1.0,
           'k8':0.5,
           'k9':0.1,
           'k10':0.02,
           'k11':1.,
           'k12d':0.2,
           'k12dd':50,
           'k12ddd':100,
           'k13':1.,
           'k14':1.,
           'k15d':1.5,
           'k15dd':0.05,
           'k16d':1.0,
           'k16dd':3.0,
           'mu':0.01,
           'J5':0.3,
           'n':4,
           'J7':1e-3,
           'J8':1e-3,
           'Keq':1e3,
           'J15':0.01,
           'J16':0.01,
           'mstar':10,
       }

       page = st.sidebar.selectbox('Jump to...',['Introduction',
                                                 'Cdh1-CycB Antagonism',
                                                 'Hysteresis in transitions',
                                                 'Regulation of Cdh1/APC',
                                                 'A primitive model',
                                                 'The yeast cell cycle'])
       if page == 'Introduction':
           st.header('Introduction')
           makeIntroPage()
       if page == 'Cdh1-CycB Antagonism':
           # st.header('A simplified model of CycB/Cdk1-Cdh1/APC antagonism')
           makeFig2(parameters)
       if page == 'Hysteresis in transitions':
           st.header('Hystersis underlies cell state transitions')
           st.markdown('in progress...')
           #makeFig3(parameters)
       if page == 'A primitive model':
           st.header('Full Model')
           plottimecourses(parameters)
       if page == 'The yeast cell cycle':
           st.header('The Yeast cell cycle')
           st.markdown('under construction')
           #plottimecourses(parameters)
   if __name__ == '__main__':
       main()
 #+end_src

 #+RESULTS:

* Markdown Text
** Intro
#+begin_src markdown :tangle markdown/intro.md
  TLDR; This project seeks to make a series of abstract models of the
  eukaryotic cell cycle accessble to non-modelers. The content is
  organized as per the ideas developed in [Tyson and Novak,
  2001](https://www.ncbi.nlm.nih.gov/pubmed/11371178).  This interactive
  site is meant to be an educational tool, aimed at anyone who has been
  exposed to the basic concepts of eukaroytic mitosis, and is curious
  about the utility of mathematical models in making sense of complex
  biological processes.

  ## What are the cell cycle models all about?
  All cells go through a cycle of events where they grow and divide:
  when the cell judges that there is sufficient nutrition available in the
  environment, it commits to duplicating its genome (S phase). Following 
  a gap phase where the cell ensures that the DNA is not damaged(G2 phase),
  the cell commits to dividing into two daughter cells. What follows is 
  an intricate orchestra of cellular events: the genome is first condensed
  into chromosomes, an elaborate microtubule spindle assembles around the nucleus,
  which then pull apart the duplicated sister chromatids to the poles of the cell.
  Finally, the entire cell divides, partitioning its organelles and cytoplasm
  between its daughters. The daughter cell, at the end of mitosis, waits
  to judge the environment, waiting in G1, waiting to commit to another cycle of growth
  and division...

  Underneath this clockwork of events lies a network of signals, molecular signals,
  that act like semaphores, *committing* the cell to the next phase of the cell cycle.
  How does this molecular network make these irreversible decisions? Tyson and Novak
  explore this question in a series of mathematical models, adding molecular
  complexity at each stage, investigating the origins of cellular decision making. 
  Use the tabs on the left to explore them!

  ## Why did you make this?
  The prototypical mathematical model of biological systems still seems
  to be the Lotka-Volterra predator-prey model, from the 20th
  century. The curious student with an interest in molecular biology
  ,*may* have come across the
  [reprissilator](https://en.wikipedia.org/wiki/Repressilator).  I
  believe that there is still a general lack of awareness of the success
  of mathematical models of cellular processes, ranging from the cell
  cycle, to circadian oscillations, to autophagy, and even dynamical
  models of cancer.  While there are general purpose tools [Cell
  Collective](https://cellcollective.org/#) that provide platforms to
  lower the barrier to entry to these theoretical models, I have not
  come across a curated, interactive resource exploring any of these
  models in depth. This is my attempt at creating such a tool, focussed
  on the highly successful work by Tyson and Novak in the last couple of
  decades on the yeast cell cycle.

  Please feel free to reach out with any feedback and comments!

  email: jamogh [at] vt [dot] edu

  twitter: [@amogh_jalihal](https://twitter.com/amogh_jalihal)

  github: this project's [github repository](https://github.com/amoghpj/cell-cycle-models)
#+end_src
** two variable model
#+begin_src markdown :tangle markdown/two-variable-timecourse.md
## The CycB/Cdk1-Cdh1/APC antagonism
We'll start at the end, the exit from mitosis. 

There are two players that coordinate the end of cell division, and the
entry into G1, namely the CycB-bound Cdk1 [kinase](https://www.uniprot.org/keywords/KW-0418), 
and the Cdh1 bound APC [ubiquitin ligase](https://www.sciencedirect.com/topics/neuroscience/anaphase-promoting-complex)
The rise in activity of the CycB/Cdk1 kinase pushes the 
cell into mitosis, spcifically into the S/G2/M phases. CycB/Cdk1
phosphorylate Cdh1 and prevent its binding to APC. In opposition,
Cdh1/APC target CycB/Cdk1 for degradation. The switch from S/G2/M to
G1 phase happens when CycB/Cdk1 is degraded, and Cdh1/APC activity is high.


These opposing forces can be modeled using a pair of non-linear ODEs, with kinetic
parameters: the *k*s are rate constants, and the *J*s are the Michaelis constants.

$\frac{d[\text{CycB}]}{dt} = k_1 - (k_2' + k_2'' [\text{Cdh1}])[\text{CycB}]$

$\frac{d[\text{Cdh1}]}{dt} = \frac{(k_3' + k_3'' A)(1- [\text{Cdh1}])}{J_3 + 1 - [\text{Cdh1}]} - \frac{k_4 m [\text{CycB}] [\text{Cdh1}]}{J_4 + [\text{Cdh1}]}$

Notice the *m* in the Cdh1 equation: it denotes the *mass* of the cell. 
The numerical solution of the above equations, the timecourses of Cdh1 (solid) and CycB (dashed),
 are plotted below. Notice the logarithmic scale of CycB activity.
The default values of these sliders (high Cdh1, low CycB, low mass) indicate that
the cell has just divided. Try increasing the mass to, and beyond, a value of 0.53.
To get a sense of how the mass affects the *dynamics* of these two opposing 
molecular factors, use the sliders to set the initial conditions of Cdh1, and CycB, and
vary the mass to see where these requlators end up at the end of the time course.
#+end_src
#+begin_src markdown :tangle markdown/two-variable-nullcline.md
  You will notice that there is a dramatic switch when mass hits a threshold,
   suddenly CycB shoots up, and Cdh1 goes down. At this point the cell has
  committed to the S/G2/M phases, and is ready to divide. But since division
  results in the *mass* of the cell dividing into its daughters, use the slider
  to set *m* to a low value  again. Notice that the configurations of CycB and Cdh1
  have flipped again.

  The exercise above shows the effect of mass on the CycB-Cdh1
  antagonism.  In order to get a sense of how this two-component system
  behaves in general, the plot below shows the nullclines of this
  system, that is, how Cdh1 (red) and CycB (blue) behave at steady
  state. The intersection of these curves (green dots) indicate the
  "fixed points" of the system, i.e. any trajectory will either be
  attracted to, or repelled by these points. Initially, the system has
  three "solutions": The one on the right is the G1 attractor. (It is an
  attractor, becasue the trajectory (starting at high Cdh1, low CycB,
  low mass) ends up falling into the green point). The one on the left
  is the S/G2/M attractor. 

  Use the sliders to increase the mass slowly, and observe the behavior of
  the green dots, and the trajectory (dashed line). Is the fixed point in 
  the middle an attractor or a repeller? What does the stability of this point
  mean for the two other fixed points?
#+end_src

#+begin_src markdown :tangle markdown/two-variable-conclusion.md
You should see the two fixed points on the right collide and disappear, at which
point the trajectory again dramatically slides along the Cdh1 nullcline, and
falls into the S/G2/M state.

Notice how the solutions of the intersecting nullclines depend on the value of the mass.
In the next section, we will plot these possible solutions directly as a function
of increase mass.
#+end_src

* [4/6] Tasks
- [X] Make function to toggle phase plane
  - This doesn't really work in the log space plot.
    Might consider enabling it for general in a different app.
- [X] Read about simple numerical root finding
- [X] Read paper and come up with an outline for a story
- [X] Write some explanatory text. Doesn't have to be perfect, can be refined later.
- [ ] Add sections to develop story.
- [ ] If possible reimplement some plots using native streamlit

